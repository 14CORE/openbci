// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: variables.proto

#ifndef PROTOBUF_variables_2eproto__INCLUDED
#define PROTOBUF_variables_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace variables {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_variables_2eproto();
void protobuf_AssignDesc_variables_2eproto();
void protobuf_ShutdownFile_variables_2eproto();

class Variable;
class VariableVector;
class Blink;
class BlinkVector;
class Sample;
class SampleVector;
class Decision;
class UgmUpdate;
class Tag;
class TagVector;

// ===================================================================

class Variable : public ::google::protobuf::Message {
 public:
  Variable();
  virtual ~Variable();
  
  Variable(const Variable& from);
  
  inline Variable& operator=(const Variable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Variable& default_instance();
  
  void Swap(Variable* other);
  
  // implements Message ----------------------------------------------
  
  Variable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Variable& from);
  void MergeFrom(const Variable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:variables.Variable)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static Variable* default_instance_;
};
// -------------------------------------------------------------------

class VariableVector : public ::google::protobuf::Message {
 public:
  VariableVector();
  virtual ~VariableVector();
  
  VariableVector(const VariableVector& from);
  
  inline VariableVector& operator=(const VariableVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VariableVector& default_instance();
  
  void Swap(VariableVector* other);
  
  // implements Message ----------------------------------------------
  
  VariableVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VariableVector& from);
  void MergeFrom(const VariableVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .variables.Variable variables = 1;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 1;
  inline const ::variables::Variable& variables(int index) const;
  inline ::variables::Variable* mutable_variables(int index);
  inline ::variables::Variable* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::variables::Variable >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::variables::Variable >*
      mutable_variables();
  
  // @@protoc_insertion_point(class_scope:variables.VariableVector)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::variables::Variable > variables_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static VariableVector* default_instance_;
};
// -------------------------------------------------------------------

class Blink : public ::google::protobuf::Message {
 public:
  Blink();
  virtual ~Blink();
  
  Blink(const Blink& from);
  
  inline Blink& operator=(const Blink& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Blink& default_instance();
  
  void Swap(Blink* other);
  
  // implements Message ----------------------------------------------
  
  Blink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Blink& from);
  void MergeFrom(const Blink& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);
  
  // required double timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline double timestamp() const;
  inline void set_timestamp(double value);
  
  // @@protoc_insertion_point(class_scope:variables.Blink)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double timestamp_;
  ::google::protobuf::int32 index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static Blink* default_instance_;
};
// -------------------------------------------------------------------

class BlinkVector : public ::google::protobuf::Message {
 public:
  BlinkVector();
  virtual ~BlinkVector();
  
  BlinkVector(const BlinkVector& from);
  
  inline BlinkVector& operator=(const BlinkVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlinkVector& default_instance();
  
  void Swap(BlinkVector* other);
  
  // implements Message ----------------------------------------------
  
  BlinkVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlinkVector& from);
  void MergeFrom(const BlinkVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .variables.Blink blinks = 1;
  inline int blinks_size() const;
  inline void clear_blinks();
  static const int kBlinksFieldNumber = 1;
  inline const ::variables::Blink& blinks(int index) const;
  inline ::variables::Blink* mutable_blinks(int index);
  inline ::variables::Blink* add_blinks();
  inline const ::google::protobuf::RepeatedPtrField< ::variables::Blink >&
      blinks() const;
  inline ::google::protobuf::RepeatedPtrField< ::variables::Blink >*
      mutable_blinks();
  
  // @@protoc_insertion_point(class_scope:variables.BlinkVector)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::variables::Blink > blinks_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static BlinkVector* default_instance_;
};
// -------------------------------------------------------------------

class Sample : public ::google::protobuf::Message {
 public:
  Sample();
  virtual ~Sample();
  
  Sample(const Sample& from);
  
  inline Sample& operator=(const Sample& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sample& default_instance();
  
  void Swap(Sample* other);
  
  // implements Message ----------------------------------------------
  
  Sample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sample& from);
  void MergeFrom(const Sample& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);
  
  // repeated double channels = 2;
  inline int channels_size() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 2;
  inline double channels(int index) const;
  inline void set_channels(int index, double value);
  inline void add_channels(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      channels() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_channels();
  
  // @@protoc_insertion_point(class_scope:variables.Sample)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double timestamp_;
  ::google::protobuf::RepeatedField< double > channels_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static Sample* default_instance_;
};
// -------------------------------------------------------------------

class SampleVector : public ::google::protobuf::Message {
 public:
  SampleVector();
  virtual ~SampleVector();
  
  SampleVector(const SampleVector& from);
  
  inline SampleVector& operator=(const SampleVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SampleVector& default_instance();
  
  void Swap(SampleVector* other);
  
  // implements Message ----------------------------------------------
  
  SampleVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SampleVector& from);
  void MergeFrom(const SampleVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .variables.Sample samples = 1;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 1;
  inline const ::variables::Sample& samples(int index) const;
  inline ::variables::Sample* mutable_samples(int index);
  inline ::variables::Sample* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::variables::Sample >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::variables::Sample >*
      mutable_samples();
  
  // @@protoc_insertion_point(class_scope:variables.SampleVector)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::variables::Sample > samples_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static SampleVector* default_instance_;
};
// -------------------------------------------------------------------

class Decision : public ::google::protobuf::Message {
 public:
  Decision();
  virtual ~Decision();
  
  Decision(const Decision& from);
  
  inline Decision& operator=(const Decision& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Decision& default_instance();
  
  void Swap(Decision* other);
  
  // implements Message ----------------------------------------------
  
  Decision* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Decision& from);
  void MergeFrom(const Decision& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 decision = 1;
  inline bool has_decision() const;
  inline void clear_decision();
  static const int kDecisionFieldNumber = 1;
  inline ::google::protobuf::int32 decision() const;
  inline void set_decision(::google::protobuf::int32 value);
  
  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:variables.Decision)
 private:
  inline void set_has_decision();
  inline void clear_has_decision();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 decision_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static Decision* default_instance_;
};
// -------------------------------------------------------------------

class UgmUpdate : public ::google::protobuf::Message {
 public:
  UgmUpdate();
  virtual ~UgmUpdate();
  
  UgmUpdate(const UgmUpdate& from);
  
  inline UgmUpdate& operator=(const UgmUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UgmUpdate& default_instance();
  
  void Swap(UgmUpdate* other);
  
  // implements Message ----------------------------------------------
  
  UgmUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UgmUpdate& from);
  void MergeFrom(const UgmUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:variables.UgmUpdate)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* value_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static UgmUpdate* default_instance_;
};
// -------------------------------------------------------------------

class Tag : public ::google::protobuf::Message {
 public:
  Tag();
  virtual ~Tag();
  
  Tag(const Tag& from);
  
  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tag& default_instance();
  
  void Swap(Tag* other);
  
  // implements Message ----------------------------------------------
  
  Tag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tag& from);
  void MergeFrom(const Tag& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double start_timestamp = 1;
  inline bool has_start_timestamp() const;
  inline void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  inline double start_timestamp() const;
  inline void set_start_timestamp(double value);
  
  // required double end_timestamp = 2;
  inline bool has_end_timestamp() const;
  inline void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 2;
  inline double end_timestamp() const;
  inline void set_end_timestamp(double value);
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string channels = 4;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 4;
  inline const ::std::string& channels() const;
  inline void set_channels(const ::std::string& value);
  inline void set_channels(const char* value);
  inline void set_channels(const char* value, size_t size);
  inline ::std::string* mutable_channels();
  inline ::std::string* release_channels();
  
  // optional .variables.VariableVector desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::variables::VariableVector& desc() const;
  inline ::variables::VariableVector* mutable_desc();
  inline ::variables::VariableVector* release_desc();
  
  // @@protoc_insertion_point(class_scope:variables.Tag)
 private:
  inline void set_has_start_timestamp();
  inline void clear_has_start_timestamp();
  inline void set_has_end_timestamp();
  inline void clear_has_end_timestamp();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_desc();
  inline void clear_has_desc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double start_timestamp_;
  double end_timestamp_;
  ::std::string* name_;
  ::std::string* channels_;
  ::variables::VariableVector* desc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static Tag* default_instance_;
};
// -------------------------------------------------------------------

class TagVector : public ::google::protobuf::Message {
 public:
  TagVector();
  virtual ~TagVector();
  
  TagVector(const TagVector& from);
  
  inline TagVector& operator=(const TagVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TagVector& default_instance();
  
  void Swap(TagVector* other);
  
  // implements Message ----------------------------------------------
  
  TagVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TagVector& from);
  void MergeFrom(const TagVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .variables.Tag tags = 1;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 1;
  inline const ::variables::Tag& tags(int index) const;
  inline ::variables::Tag* mutable_tags(int index);
  inline ::variables::Tag* add_tags();
  inline const ::google::protobuf::RepeatedPtrField< ::variables::Tag >&
      tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::variables::Tag >*
      mutable_tags();
  
  // @@protoc_insertion_point(class_scope:variables.TagVector)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::variables::Tag > tags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_variables_2eproto();
  friend void protobuf_AssignDesc_variables_2eproto();
  friend void protobuf_ShutdownFile_variables_2eproto();
  
  void InitAsDefaultInstance();
  static TagVector* default_instance_;
};
// ===================================================================


// ===================================================================

// Variable

// required string key = 1;
inline bool Variable::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Variable::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Variable::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Variable::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Variable::key() const {
  return *key_;
}
inline void Variable::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Variable::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Variable::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Variable::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Variable::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string value = 2;
inline bool Variable::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Variable::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Variable::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Variable::value() const {
  return *value_;
}
inline void Variable::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Variable::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Variable::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Variable::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Variable::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// VariableVector

// repeated .variables.Variable variables = 1;
inline int VariableVector::variables_size() const {
  return variables_.size();
}
inline void VariableVector::clear_variables() {
  variables_.Clear();
}
inline const ::variables::Variable& VariableVector::variables(int index) const {
  return variables_.Get(index);
}
inline ::variables::Variable* VariableVector::mutable_variables(int index) {
  return variables_.Mutable(index);
}
inline ::variables::Variable* VariableVector::add_variables() {
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::variables::Variable >&
VariableVector::variables() const {
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::variables::Variable >*
VariableVector::mutable_variables() {
  return &variables_;
}

// -------------------------------------------------------------------

// Blink

// required int32 index = 1;
inline bool Blink::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Blink::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Blink::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Blink::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Blink::index() const {
  return index_;
}
inline void Blink::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required double timestamp = 2;
inline bool Blink::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Blink::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Blink::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Blink::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Blink::timestamp() const {
  return timestamp_;
}
inline void Blink::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// BlinkVector

// repeated .variables.Blink blinks = 1;
inline int BlinkVector::blinks_size() const {
  return blinks_.size();
}
inline void BlinkVector::clear_blinks() {
  blinks_.Clear();
}
inline const ::variables::Blink& BlinkVector::blinks(int index) const {
  return blinks_.Get(index);
}
inline ::variables::Blink* BlinkVector::mutable_blinks(int index) {
  return blinks_.Mutable(index);
}
inline ::variables::Blink* BlinkVector::add_blinks() {
  return blinks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::variables::Blink >&
BlinkVector::blinks() const {
  return blinks_;
}
inline ::google::protobuf::RepeatedPtrField< ::variables::Blink >*
BlinkVector::mutable_blinks() {
  return &blinks_;
}

// -------------------------------------------------------------------

// Sample

// required double timestamp = 1;
inline bool Sample::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sample::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sample::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sample::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double Sample::timestamp() const {
  return timestamp_;
}
inline void Sample::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated double channels = 2;
inline int Sample::channels_size() const {
  return channels_.size();
}
inline void Sample::clear_channels() {
  channels_.Clear();
}
inline double Sample::channels(int index) const {
  return channels_.Get(index);
}
inline void Sample::set_channels(int index, double value) {
  channels_.Set(index, value);
}
inline void Sample::add_channels(double value) {
  channels_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
Sample::channels() const {
  return channels_;
}
inline ::google::protobuf::RepeatedField< double >*
Sample::mutable_channels() {
  return &channels_;
}

// -------------------------------------------------------------------

// SampleVector

// repeated .variables.Sample samples = 1;
inline int SampleVector::samples_size() const {
  return samples_.size();
}
inline void SampleVector::clear_samples() {
  samples_.Clear();
}
inline const ::variables::Sample& SampleVector::samples(int index) const {
  return samples_.Get(index);
}
inline ::variables::Sample* SampleVector::mutable_samples(int index) {
  return samples_.Mutable(index);
}
inline ::variables::Sample* SampleVector::add_samples() {
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::variables::Sample >&
SampleVector::samples() const {
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::variables::Sample >*
SampleVector::mutable_samples() {
  return &samples_;
}

// -------------------------------------------------------------------

// Decision

// required int32 decision = 1;
inline bool Decision::has_decision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Decision::set_has_decision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Decision::clear_has_decision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Decision::clear_decision() {
  decision_ = 0;
  clear_has_decision();
}
inline ::google::protobuf::int32 Decision::decision() const {
  return decision_;
}
inline void Decision::set_decision(::google::protobuf::int32 value) {
  set_has_decision();
  decision_ = value;
}

// optional int32 type = 2;
inline bool Decision::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Decision::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Decision::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Decision::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Decision::type() const {
  return type_;
}
inline void Decision::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// UgmUpdate

// required int32 type = 1;
inline bool UgmUpdate::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UgmUpdate::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UgmUpdate::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UgmUpdate::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UgmUpdate::type() const {
  return type_;
}
inline void UgmUpdate::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string value = 2;
inline bool UgmUpdate::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UgmUpdate::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UgmUpdate::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UgmUpdate::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& UgmUpdate::value() const {
  return *value_;
}
inline void UgmUpdate::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UgmUpdate::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UgmUpdate::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UgmUpdate::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* UgmUpdate::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Tag

// required double start_timestamp = 1;
inline bool Tag::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tag::set_has_start_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tag::clear_has_start_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tag::clear_start_timestamp() {
  start_timestamp_ = 0;
  clear_has_start_timestamp();
}
inline double Tag::start_timestamp() const {
  return start_timestamp_;
}
inline void Tag::set_start_timestamp(double value) {
  set_has_start_timestamp();
  start_timestamp_ = value;
}

// required double end_timestamp = 2;
inline bool Tag::has_end_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tag::set_has_end_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tag::clear_has_end_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tag::clear_end_timestamp() {
  end_timestamp_ = 0;
  clear_has_end_timestamp();
}
inline double Tag::end_timestamp() const {
  return end_timestamp_;
}
inline void Tag::set_end_timestamp(double value) {
  set_has_end_timestamp();
  end_timestamp_ = value;
}

// required string name = 3;
inline bool Tag::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tag::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tag::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tag::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Tag::name() const {
  return *name_;
}
inline void Tag::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tag::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tag::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tag::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Tag::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string channels = 4;
inline bool Tag::has_channels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Tag::set_has_channels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Tag::clear_has_channels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Tag::clear_channels() {
  if (channels_ != &::google::protobuf::internal::kEmptyString) {
    channels_->clear();
  }
  clear_has_channels();
}
inline const ::std::string& Tag::channels() const {
  return *channels_;
}
inline void Tag::set_channels(const ::std::string& value) {
  set_has_channels();
  if (channels_ == &::google::protobuf::internal::kEmptyString) {
    channels_ = new ::std::string;
  }
  channels_->assign(value);
}
inline void Tag::set_channels(const char* value) {
  set_has_channels();
  if (channels_ == &::google::protobuf::internal::kEmptyString) {
    channels_ = new ::std::string;
  }
  channels_->assign(value);
}
inline void Tag::set_channels(const char* value, size_t size) {
  set_has_channels();
  if (channels_ == &::google::protobuf::internal::kEmptyString) {
    channels_ = new ::std::string;
  }
  channels_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tag::mutable_channels() {
  set_has_channels();
  if (channels_ == &::google::protobuf::internal::kEmptyString) {
    channels_ = new ::std::string;
  }
  return channels_;
}
inline ::std::string* Tag::release_channels() {
  clear_has_channels();
  if (channels_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channels_;
    channels_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .variables.VariableVector desc = 5;
inline bool Tag::has_desc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Tag::set_has_desc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Tag::clear_has_desc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Tag::clear_desc() {
  if (desc_ != NULL) desc_->::variables::VariableVector::Clear();
  clear_has_desc();
}
inline const ::variables::VariableVector& Tag::desc() const {
  return desc_ != NULL ? *desc_ : *default_instance_->desc_;
}
inline ::variables::VariableVector* Tag::mutable_desc() {
  set_has_desc();
  if (desc_ == NULL) desc_ = new ::variables::VariableVector;
  return desc_;
}
inline ::variables::VariableVector* Tag::release_desc() {
  clear_has_desc();
  ::variables::VariableVector* temp = desc_;
  desc_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// TagVector

// repeated .variables.Tag tags = 1;
inline int TagVector::tags_size() const {
  return tags_.size();
}
inline void TagVector::clear_tags() {
  tags_.Clear();
}
inline const ::variables::Tag& TagVector::tags(int index) const {
  return tags_.Get(index);
}
inline ::variables::Tag* TagVector::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline ::variables::Tag* TagVector::add_tags() {
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::variables::Tag >&
TagVector::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::variables::Tag >*
TagVector::mutable_tags() {
  return &tags_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace variables

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_variables_2eproto__INCLUDED
